<?php

namespace Faucon\Bundle\RankingBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Symfony\Component\DependencyInjection\Container;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Faucon\DataProviders\IDataTablesRepository;

/**
 * RankingRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class RankingRepository extends EntityRepository implements IDataTablesRepository
{
    private $container = null;

    public function setContainer(Container $container)
    {
        $this->container = $container;
    }
    
    public function getMaxItemsPerLayer()
    {
        if (is_null($this->container))
        {
            return 6;
        }
        return $this->container->getParameter('maxitemsperlayer');
    }

    public function getByCategory($category)
    {
        return $this->getEntityManager()
                ->createQueryBuilder()
                ->select('r')
                ->from('FauconRankingBundle:Ranking' ,'r')
                ->where('r.category = ?1')
                ->setParameter('1', $category)
                ->orderBy('r.ranking')
                ->getQuery()
                ->getResult();
    }
    
    public function getUsersByCategory(\Faucon\Bundle\RankingBundle\Entity\Category $category)
    {
        return $this->getEntityManager()
                ->createQueryBuilder()
                ->select('r, p')
                ->from('FauconRankingBundle:Ranking', 'r')
                ->join('r.player', 'p')
                ->where('r.category = ?1')
                ->setParameter(1, $category)
                ->orderBy('p.lastname, p.firstname', 'ASC')
                ->getQuery()
                ->getResult();
    }
    
    public function getUserByRankAndCategory($rank, \Faucon\Bundle\RankingBundle\Entity\Category $category)
    {
        try
        {
            $ranking = $this->getEntityManager()
                        ->createQuery('select r from FauconRankingBundle:Ranking r where r.category = :category and r.ranking = :rank')
                        ->setParameter('category', $category)
                        ->setParameter('rank', $rank)
                        ->getSingleResult();
            return $ranking->getPlayer();
        }
        catch (\Doctrine\ORM\NoResultException $ex)
        {
            return null;
        }
    }
    
    private function getCountBeforeItemsPerLayerIsAdjusted()
    {
        $count = 0;
        $max = $this->getMaxItemsPerLayer();
        $itemsPerLayer = 0;
        $layer = 0;
        while ($itemsPerLayer < $max) {
            $count = 0.5*$layer*$layer + 0.5*$layer;
            $itemsPerLayer = $this->getNumberOfPlayersForLayer($layer);
            $layer++;
        }
        return $count;
    }
    
    protected function getUncorrectedNumberOfPlayersPerLayer($layer)
    {
        $layer_ = $layer - 1;
        return (0.5*$layer*$layer + 0.5*$layer) - (0.5*$layer_*$layer_ + 0.5*$layer_);
    }

    protected function adjustLayer($layer, $ranking)
    {
        $pointOfAction = $this->getCountBeforeItemsPerLayerIsAdjusted() + $this->getMaxItemsPerLayer();
        if ($ranking <= $pointOfAction) {
            return $layer;
        }
        $diff = $ranking - $pointOfAction;
        $ratio = floor($diff / $this->getMaxItemsPerLayer());
        $layer = 8 + $ratio; // FIXME how to determine that it should be 8??
        if ($diff % $this->getMaxItemsPerLayer() == 0) {
            $layer--;
        }
        return $layer;
    }
    
    public function getLayer($ranking)
    {
        $d = sqrt(0.5*0.5-4*0.5*-$ranking);
        $layer = (-0.5+$d);
        if ($layer == abs($layer)) {
            return $this->adjustLayer(ceil($layer), $ranking);
        }
        $layer = (-0.5-$d);
        if ($layer == abs($layer)) {
            return $this->adjustLayer(ceil($layer), $ranking);
        }
    }
    
    
    public function getLayerForRanking($layer, $ranking)
    {
        //0.5*$layers*$layers + 0.5*$layers;
        if (0.5*$layer*$layer + 0.5*$layer >= $ranking) {
            return $layer;
        }
        else {
            return $this->getLayerForRanking($layer+1, $ranking);
        }
    }
    
    private function getNumberOfTotalPlayersForLayer($layer)
    {
        $playercount = 0;
        for ($i = 0; $i < $layer; $i++) {
            if (0.5*$i*$i + 0.5*$i < $this->getMaxItemsPerLayer()) {
                 $playercount = 0.5*$i*$i + 0.5*$i;
             }
             else {
                $playercount += $this->getMaxItemsPerLayer();
             }
         }
        return $playercount;
    }
    
    private function getNumberOfPlayersForLayer($layer)
    {
        $maxitems =  $this->getMaxItemsPerLayer();
        $layer_ = $layer - 1;
        $playercount = (0.5*$layer*$layer + 0.5*$layer) - (0.5*$layer_*$layer_ + 0.5*$layer_);
        if ($playercount > $maxitems) {
            return $maxitems;
        }
        return $playercount;
    }
    
    public function getLayers($count)
    {
        $layers = 0;
        $items = 0;
        $formula = 0;
        while ($count >= $items) {
            $layers++;
            $formula = 0.5*$layers*$layers + 0.5*$layers;
            if ($formula < $this->getMaxItemsPerLayer()) {
                $items = $formula;
            }
            else {
                $items += $this->getMaxItemsPerLayer();
            }
        }
        return $layers;
    }

    public function updateRankings(\Faucon\Bundle\ClubBundle\Entity\User $user, \Faucon\Bundle\RankingBundle\Entity\Category $category, $newranking, $oldranking)
    {
        if ($newranking == null && $oldranking == null)
        {
            throw new Exception('Old and new ranking cant both be null');
        }
        $query = $this
            ->getEntityManager()
            ->createQueryBuilder()
            ->update('FauconRankingBundle:Ranking', 'r');
        if ($newranking == null)
        {
            $query = $query
                ->set('r.ranking', 'r.ranking - 1')
                ->where('r.ranking > ?1')
                ->setParameter(1, $oldranking);
        }
        else if ($oldranking == null) // new player added to the ranking of this category
        {
            $query = $query
                ->set('r.ranking', 'r.ranking + 1')
                ->where('r.ranking >= ?1')
                ->setParameter(1, $newranking);
        }
        else if ($oldranking > $newranking) // player got a better ranking
        {
            $query = $query
                  ->set('r.ranking', 'r.ranking + 1')
                  ->where('r.ranking < ?2')
                  ->andWhere('r.ranking >= ?3')
                  ->setParameter(2, $oldranking)
                  ->setParameter(3, $newranking);
        }
        else
        {
            $query = $query
                ->set('r.ranking', 'r.ranking - 1')
                ->where('r.ranking > ?4')
                ->andWhere('r.ranking <= ?5')
                ->setParameter(4, $oldranking)
                ->setParameter(5, $newranking);
        }
        // only update rankings in current category
        $query = $query
            ->andWhere('r.category = ?6')
            ->setParameter(6, $category)
            ->getQuery();
        $query->execute();
    }
    
    public function getRankingArray(\Faucon\Bundle\ClubBundle\Entity\User $currentplayer = null, \Faucon\Bundle\RankingBundle\Entity\Category $category)
    {
        $userrepository = $this->getEntityManager()
                ->getRepository('FauconClubBundle:User');
        $clubrelationrepository = $this->getEntityManager()
                ->getRepository('FauconClubBundle:ClubRelation');
        $cat = $this
            ->getEntityManager()
            ->createQueryBuilder()
            ->select('c, cl')
            ->from('FauconRankingBundle:Category', 'c')
            ->join('c.club', 'cl')
            ->where('c = ?1')
            ->setParameter(1, $category)
            ->getQuery()
            ->getOneOrNullResult();
        $rankings = $this
            ->getEntityManager()
            ->createQueryBuilder()
            ->select('r')
            ->from('FauconRankingBundle:Ranking', 'r')
            ->where('r.category = ?1')
            ->setParameter(1, $category)
            ->orderBy('r.ranking')
            ->getQuery()
            ->getResult();
        $count = count($rankings);
        if ($count == 0)
        {
          return;
        }
        $items = array();
        foreach ($rankings as $ranking) {
            $items[] = array(
                'ranking' => $ranking,
                'canChallenge' => $userrepository->canChallenge($currentplayer, $category, $ranking),
                'hasLicense' => $clubrelationrepository->hasLicense($ranking->getPlayer(), $cat->getClub())
                );
        }
        return array('data' => $this->getPyramidArray($items), 'count' => $count, 'layers' => $this->getLayer($count));
    }
    
    public function getPyramidArray($rankings)
    {
        $pyramid = array();
        for ($i = 1; $i <= count($rankings); $i++) {
            $layer = $this->getLayer($i);
            if (!isset($pyramid[$layer])) {
                $pyramid[$layer] = array();
            }
            $pyramid[$layer][] = $rankings[$i-1];
        }
        if ($this->getNumberOfPlayersForLayer($this->getLayers(count($rankings))) == $this->getMaxItemsPerLayer()) {
            $array = array_pop($pyramid);
            while(count($array) < 6) {
                array_push($array, array(
                    'ranking' => null,
                    'canChallenge' => false,
                    'hasLicense' => false
                ));
            }
            array_push($pyramid, $array);
        }
        return $pyramid;
    }
    
    public function getNextRankingInCategory(\Faucon\Bundle\RankingBundle\Entity\Category $category)
    {
        $next = $this->getEntityManager()
                ->createQueryBuilder()
                ->select('max(r.ranking)+1')
                ->from('FauconRankingBundle:Ranking', 'r')
                ->where('r.category = ?1')
                ->setParameter(1, $category)
                ->getQuery()
                ->getSingleScalarResult();
        if ($next === null) {
            return 1;
        }
        return $next;
    }

    public function getDataTablesResult(ContainerInterface $container, $pageoffset, $pagesize, $options)
    {
        $dateutility = $container->get('date_utility');
        $qb = $this->getEntityManager()
            ->createQueryBuilder();
        $qb = $qb->select('c')
            ->from('FauconRankingBundle:Category', 'c')
            ->join('c.club', 'cl');
        $categories = $this->getUsersCategories($container);
        if (count($categories) > 0) {
            $qb = $qb->where($qb->expr()->in('c', $categories));
        }
        $result = $qb->orderBy('cl.country')
            ->orderBy('cl.name')
            ->orderBy('c.name')
            ->setFirstResult($pageoffset)
            ->setMaxResults($pagesize)
            ->getQuery()
            ->getResult();
        $engine = $container->get('templating');
        $data = array();
        foreach ($result as $category)
        {
            $row = array();
            $row[] = $category->getName();
            $row[] = $category->getDescription();
            $row[] = $dateutility->ago($category->getCreated()->format('Y-m-d H:i:s'));
            $row[] = $category->getClub()->getName();
            $row[] = $engine->render('FauconRankingBundle:Ranking:linktoranking.html.twig', array('entity' => $category));
            $data[] = $row;
        }
        return $data;
    }

    private function getUsersCategories(ContainerInterface $container)
    {
        if ($container->get('security.context')->isGranted('ROLE_USER')) {
            $user = $container->get('security.context')->getToken()->getUser();
            $rankings = $this->getEntityManager()->createQueryBuilder()
                    ->select('c, r')
                    ->from('FauconRankingBundle:Ranking', 'r')
                    ->join('r.category', 'c')
                    ->join('r.player', 'p')
                    ->where('p = ?1')
                    ->setParameter(1, $user)
                    ->getQuery()
                    ->getResult();
            $categories = array();
            foreach($rankings as $ranking) {
                $categories[] = $ranking->getCategory()->getId();
            }
            return $categories;
        }
        return null;
    }

    public function getDataTablesRowsCount(ContainerInterface $container)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb = $qb->select('count(c)')
            ->from('FauconRankingBundle:Category', 'c');
        $categories = $this->getUsersCategories($container);
        if (count($categories) > 0) {
            $qb = $qb->where($qb->expr()->in('c', $categories));
        }
        return $qb->getQuery()
            ->getSingleScalarResult();

    }
    
    private function getNewRanking(\Faucon\Bundle\RankingBundle\Entity\Ranking $ranking, $rankingobject)
    {
        foreach($rankingobject->rankings as  $rank) {
            if ($rank->id == $ranking->getId()) {
                return $rank->index;
            }
        }
        return null;
    }
    
    public function updateRankingsInCategory(\Faucon\Bundle\RankingBundle\Entity\Category $category, $rankingsjson)
    {
        $rankings = json_decode($rankingsjson)->rankings;
        $sql = 'insert into ranking_ranking (id, ranking) values';
        $addComma = false;
        foreach ($rankings as $ranking) {
            if ($addComma) {
                $sql .= ',';
            }
            else {
                $addComma = true;
            }
            $sql .= '('.$ranking->id.', '.$ranking->index.')';
        }
        $sql .= 'on duplicate key update ranking=values(ranking);';
        $this->getEntityManager()
                ->getConnection()
                ->exec($sql);
    }
}